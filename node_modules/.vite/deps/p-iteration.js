import {
  __commonJS
} from "./chunk-6RGDVRFG.js";

// node_modules/p-iteration/lib/static-methods.js
var require_static_methods = __commonJS({
  "node_modules/p-iteration/lib/static-methods.js"(exports) {
    exports.forEach = async (array, callback, thisArg) => {
      const promiseArray = [];
      for (let i = 0; i < array.length; i++) {
        if (i in array) {
          const p = Promise.resolve(array[i]).then((currentValue) => {
            return callback.call(thisArg || exports, currentValue, i, array);
          });
          promiseArray.push(p);
        }
      }
      await Promise.all(promiseArray);
    };
    exports.forEachSeries = async (array, callback, thisArg) => {
      for (let i = 0; i < array.length; i++) {
        if (i in array) {
          await callback.call(thisArg || exports, await array[i], i, array);
        }
      }
    };
    exports.map = async (array, callback, thisArg) => {
      const promiseArray = [];
      for (let i = 0; i < array.length; i++) {
        if (i in array) {
          promiseArray[i] = Promise.resolve(array[i]).then((currentValue) => {
            return callback.call(thisArg || exports, currentValue, i, array);
          });
        }
      }
      return Promise.all(promiseArray);
    };
    exports.mapSeries = async (array, callback, thisArg) => {
      const result = [];
      for (let i = 0; i < array.length; i++) {
        if (i in array) {
          result[i] = await callback.call(thisArg || exports, await array[i], i, array);
        }
      }
      return result;
    };
    exports.find = (array, callback, thisArg) => {
      return new Promise((resolve, reject) => {
        if (array.length === 0) {
          return resolve();
        }
        let counter = 1;
        for (let i = 0; i < array.length; i++) {
          const check = (found) => {
            if (found) {
              resolve(array[i]);
            } else if (counter === array.length) {
              resolve();
            }
            counter++;
          };
          Promise.resolve(array[i]).then((elem) => callback.call(thisArg || exports, elem, i, array)).then(check).catch(reject);
        }
      });
    };
    exports.findSeries = async (array, callback, thisArg) => {
      for (let i = 0; i < array.length; i++) {
        if (await callback.call(thisArg || exports, await array[i], i, array)) {
          return array[i];
        }
      }
    };
    exports.findIndex = (array, callback, thisArg) => {
      return new Promise((resolve, reject) => {
        if (array.length === 0) {
          return resolve(-1);
        }
        let counter = 1;
        for (let i = 0; i < array.length; i++) {
          const check = (found) => {
            if (found) {
              resolve(i);
            } else if (counter === array.length) {
              resolve(-1);
            }
            counter++;
          };
          Promise.resolve(array[i]).then((elem) => callback.call(thisArg || exports, elem, i, array)).then(check).catch(reject);
        }
      });
    };
    exports.findIndexSeries = async (array, callback, thisArg) => {
      for (let i = 0; i < array.length; i++) {
        if (await callback.call(thisArg || exports, await array[i], i, array)) {
          return i;
        }
      }
    };
    exports.some = (array, callback, thisArg) => {
      return new Promise((resolve, reject) => {
        if (array.length === 0) {
          return resolve(false);
        }
        let counter = 1;
        for (let i = 0; i < array.length; i++) {
          if (!(i in array)) {
            counter++;
            continue;
          }
          const check = (found) => {
            if (found) {
              resolve(true);
            } else if (counter === array.length) {
              resolve(false);
            }
            counter++;
          };
          Promise.resolve(array[i]).then((elem) => callback.call(thisArg || exports, elem, i, array)).then(check).catch(reject);
        }
      });
    };
    exports.someSeries = async (array, callback, thisArg) => {
      for (let i = 0; i < array.length; i++) {
        if (i in array && await callback.call(thisArg || exports, await array[i], i, array)) {
          return true;
        }
      }
      return false;
    };
    exports.every = (array, callback, thisArg) => {
      return new Promise((resolve, reject) => {
        if (array.length === 0) {
          return resolve(true);
        }
        let counter = 1;
        for (let i = 0; i < array.length; i++) {
          if (!(i in array)) {
            counter++;
            continue;
          }
          const check = (found) => {
            if (!found) {
              resolve(false);
            } else if (counter === array.length) {
              resolve(true);
            }
            counter++;
          };
          Promise.resolve(array[i]).then((elem) => callback.call(thisArg || exports, elem, i, array)).then(check).catch(reject);
        }
      });
    };
    exports.everySeries = async (array, callback, thisArg) => {
      for (let i = 0; i < array.length; i++) {
        if (i in array && !await callback.call(thisArg || exports, await array[i], i, array)) {
          return false;
        }
      }
      return true;
    };
    exports.filter = (array, callback, thisArg) => {
      return new Promise(async (resolve, reject) => {
        const promiseArray = [];
        for (let i = 0; i < array.length; i++) {
          if (i in array) {
            promiseArray[i] = Promise.resolve(array[i]).then((currentValue) => {
              return callback.call(thisArg || exports, currentValue, i, array);
            }).catch(reject);
          }
        }
        const filteredArray = [];
        for (let i = 0; i < promiseArray.length; i++) {
          if (await promiseArray[i]) {
            filteredArray.push(await array[i]);
          }
        }
        resolve(filteredArray);
      });
    };
    exports.filterSeries = async (array, callback, thisArg) => {
      const result = [];
      for (let i = 0; i < array.length; i++) {
        if (i in array && await callback.call(thisArg || exports, await array[i], i, array)) {
          result.push(await array[i]);
        }
      }
      return result;
    };
    exports.reduce = async (array, callback, initialValue) => {
      if (array.length === 0 && initialValue === void 0) {
        throw TypeError("Reduce of empty array with no initial value");
      }
      let i;
      let previousValue;
      if (initialValue !== void 0) {
        previousValue = initialValue;
        i = 0;
      } else {
        previousValue = array[0];
        i = 1;
      }
      for (i; i < array.length; i++) {
        if (i in array) {
          previousValue = await callback(await previousValue, await array[i], i, array);
        }
      }
      return previousValue;
    };
  }
});

// node_modules/p-iteration/lib/instance-methods.js
var require_instance_methods = __commonJS({
  "node_modules/p-iteration/lib/instance-methods.js"(exports) {
    var staticMethods = require_static_methods();
    Object.keys(staticMethods).forEach((methodName) => {
      const instaceMethodName = methodName.charAt(0).toUpperCase() + methodName.slice(1);
      exports[`async${instaceMethodName}`] = async function(...args) {
        return staticMethods[methodName](this, ...args);
      };
    });
  }
});

// node_modules/p-iteration/index.js
var require_p_iteration = __commonJS({
  "node_modules/p-iteration/index.js"(exports, module) {
    var staticMethods = require_static_methods();
    var instanceMethods = require_instance_methods();
    module.exports = Object.assign(staticMethods, { instanceMethods });
  }
});
export default require_p_iteration();
//# sourceMappingURL=p-iteration.js.map
